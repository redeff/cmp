const p : i64 = 1000000007;

fn conv(a : &[i64], b: &[i64], c: &mut [i64], d: &mut [i64], e: &mut [i64]) {
    let t = a.len();
    let k = a.len()/2;

    if t == 1 {
        c[0] = (a[0] * b[0]) % p;
        c[0] %= p;
        c[1] = 0;

    } else {
        let (ea, eb) = e.split_at_mut(t);
        conv(&a[..k], &b[..k], &mut c[..t], ea, eb);
        conv(&a[k..], &b[k..], &mut c[t..], ea, eb);

        for i in 0..k {
            d[i] = a[i] + a[i + k];
            d[i] %= p;
            d[i + k] = b[i] + b[i + k];
            d[i + k] %= p;
        }

        let (f, s) = d.split_at_mut(t);
        conv(&f[..k], &f[k..], s, ea, eb);
        for i in 0..t {
            s[i] += 2*p - c[i] - c[i + t];
        }

        for i in 0..t {
            c[k + i] += s[i];
            c[k + i] %= p;
        }
    }
}

const big : usize = 64;

fn mult(
    rec : &[i64; big],
    a: &[i64; 2*big],
    b: &[i64; 2*big],
    out: &mut [i64; 2*big],
    buffa: &mut [i64; 4*big],
    buffb: &mut [i64; 4*big],
    buffc: &mut [i64; 4*big]) {

    conv(a, b, buffa, buffb, buffc);
    conv(&buffa[3*big..], rec, buffb, out, buffc);
    for i in 0..2*big {
        buffa[i + big] += buffb[i]; 
        buffa[i + big] %= p; 
    }

    conv(&buffa[2*big..], rec, buffb, out, buffc);
    for i in 0..2*big {
        buffa[i] += buffb[i]; 
        buffa[i] %= p; 
    }

    for i in 0..2*big {
        out[i] = buffa[i];
    }
}

fn sq(rec: &[i64; big], recn: &mut[i64; big], buffa: &mut[i64; 2 * big]) {
    for i in 0..buffa.len() {
        buffa[i] = 0;
    }

    for i in 0..big {
        for j in 0..big {
            buffa[i + j] += (rec[i] * rec[j]) % p;
            buffa[i + j] %= p;
        }
    }

    for i in 0..big {
        let c = 2*big - 1 - i;
        for j in 0..big {
            buffa[c - big + j] += (buffa[c] * rec[j]) % p;
            buffa[c - big + j] %= p;
        }
    }

    for i in 0..big {
        recn[i] = buffa[i];
    }
}



fn main() {
    let buffa = vec![0; 4*big];
    let buffb = vec![0; 4*big];
    let buffc = vec![0; 4*big];

    let coeff = vec![
vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, ],
vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, -1, ],
vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, -1, -1, 1, ],
vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, -2, 0, 0, 1, 1, -1, ],
vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 1, 1, 0, 0, -1, -1, -1, 1, 1, 1, 0, 0, -1, -1, 1, ],
vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1, 1, 0, 0, -1, 0, -2, 0, 1, 1, 1, 1, 0, -2, 0, -1, 0, 0, 1, 1, -1, ],
vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, -1, 0, -1, -1, 0, 1, 1, 2, 0, 0, 0, -2, -1, -1, 0, 1, 1, 0, 1, 0, 0, -1, -1, 1, ],
vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, -1, 0, -1, 0, -1, 0, 1, 2, 1, 0,
1, -1, -1, -2, -1, -1, 1, 0, 1, 2, 1, 0, -1, 0, -1, 0, -1, 0, 0, 1, 1, -1, ],
vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, -1, 0, -1, 0, 0, -1, 0, 2, 1, 1, 1, 0, -1, -1, -1, -2, -1, -1, 1, 1, 2, 1, 1, 1, 0, -1, -1, -1, -2, 0, 1, 0, 0, 1, 0, 1, 0, 0, -1, -1, 1, ],
vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, -1, 0, -1, 0, 0, 0, -1, 1, 1, 1, 2, 0, 0, -1, -1, -1, -1, -3, 0, 0, 1, 1, 2, 2, 1, 1, 0, 0, -3, -1, -1, -1, -1, 0, 0, 2, 1, 1, 1, -1, 0, 0, 0, -1, 0, -1, 0, 0, 1, 1, -1, ],
    ];

    let dp = vec![vec![0; 2*big + 11]; 11];
    dp[0][0] = 1;

    for k in 1..11 {
        for n in 1..2*big + 11 {
            if n - k >= 0 {
                dp[k][n] += dp[k][n - k];
                dp[k][n] %= p;
            }

            if k - 1 >= 0 && n - 1 >= 0 {
                dp[k][n] += dp[k - 1][n - 1];
                dp[k][n] %= p;
            }
        }
    }

    {
        let k = 0;
        let m = "0";

        let rec = vec![0; big];
        sq(&coeff[k][..], &mut rec[..], &buffa[..2*big]);

        let mut total = vec![0; 2*big];
        total[0] = 1;

        let mut tmpa = vec![0; 2*big];
        let mut tmpb = vec![0; 2*big];

        let mut curr = vec![0; 2*big];
        curr[1] = 1;

        for b in m.as_bytes() {
            mult(rec, total, tmpb, tmpa, buffa, buffb, buffc); 
        }
    }

    // conv(&a[..], &b[..], &mut c[..], &mut d[..], &mut e[..]);

}
